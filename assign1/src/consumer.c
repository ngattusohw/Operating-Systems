#include "main.h"

// consumer function
void *consumer(void *i) {
  int consumer_id = *((int*)i);
  struct product* taken_product;
	int idx;
  // Consumers are allowed to consume products as long as the count is less than the max number of products
  while (consumedCount < numProducts) {
    // Only 1 thread can have the mutex lock at a time
    pthread_mutex_lock(&queue_lock);
    // When the count is less than the max number of products, consumers are allowed to eat if there are products available in the queue, otherside they need to wait
    while (consumedCount < numProducts && productsInQueue == 0) {
      pthread_cond_wait(&queue_not_empty, &queue_lock);
    }
    long long now;
    // Check consumedCount again to decide which clause to execute
    if (consumedCount < numProducts) {
      // FCFS
      if (scheduling == 0) {
        // Takes the product at the front of queue
        taken_product = popQueue();
        // Update wait time
        now = getTimeStamp();
        wait_time_arr[taken_product->pid-1] += now - taken_product->time_inserted;
        // calls fn(10) l times and removes the product from the queue
        idx = 0;
        while (idx < taken_product->life) {
          fn(10);
          idx++;
        }
        now = getTimeStamp();
        // Updates turn around time
        turn_around_arr[taken_product->pid-1] = now-taken_product->time_produced;
        ++consumedCount;
        printf("Consumer %d has consumed product %d\n", consumer_id, taken_product->pid);
        fflush(stdout);
        pthread_cond_broadcast(&queue_not_full);
      }
      // round robin
      else {
        // Takes the product at the front of queue
        taken_product = popQueue();
        // Update wait time
        now = getTimeStamp();
        wait_time_arr[taken_product->pid-1] += now - taken_product->time_inserted;
        // if true, the thread updates the product's life and call fn(10) q times
        if (taken_product->life > quantum)  {
          for (idx = quantum; idx  > 0; idx--) {
            fn(10);
          }
          // Updates the product's life
          taken_product->life = taken_product->life - quantum;
          // Puts the product back to queue
          pushQueue(taken_product);
        }
        else {
          // calls fn(10) l times and removes the product from the queue
          while (idx < taken_product->life) {
            fn(10);
            idx++;
          }
          now = getTimeStamp();
          // update turn around time for this product
          turn_around_arr[taken_product->pid-1] = now - taken_product->time_produced;
          ++consumedCount;
          printf("Consumer %d has consumed product %d\n", consumer_id, taken_product->pid);
          fflush(stdout);
          pthread_cond_broadcast(&queue_not_full);
        }
      }
      // unlock the mutex
      pthread_mutex_unlock(&queue_lock);
      usleep(100000);
    }
    // When all products generated by producers are consumed, an else clause will be executed for those who are still waiting for a product
    else {
      pthread_cond_broadcast(&queue_not_empty);
      pthread_mutex_unlock(&queue_lock);
      break;
    }
  }
  return NULL;
}
